# Misc Notes

# External devices

| Target                    | Canonical Tooling                                  | Preferred Language(s)    |
|---------------------------|----------------------------------------------------|---------------------------|
| Native Windows App        | Visual Studio, CMake, Cargo                        | C++, Rust                 |
| Native macOS App          | Xcode, SwiftUI, AppKit, Tauri                      | Swift, Rust, TypeScript   |
| iPhone App                | Xcode, SwiftUI                                     | Swift                     |
| Android App               | Android Studio, Jetpack Compose, Android NDK       | Kotlin, Rust              |
| Steam Game                | Unreal, Unity, Godot, Bevy                         | C++, Rust                 |
| Apple Vision App          | Xcode, SwiftUI, RealityKit                         | Swift                     |
| Apple Watch App           | Xcode, SwiftUI                                     | Swift                     |
| Chrome Extension          | Webpack, Rollup                                    | TypeScript                |
| Firefox Extension         | Webpack, Rollup                                    | TypeScript                |
| Safari Extension          | Xcode, Safari Web Extensions                       | Swift, TypeScript         |
| VSCode Extension          | VSCode Extension API, vsce                         | TypeScript                |
| Custom Boards (Raspberry Pi)| Cross-compilation (GCC, Cargo), GPIO libraries   | Python, Rust, C++         |
| Embedded Systems          | Embedded Rust (Cargo, embedded-hal), ARM GCC       | Rust, C/C++               |


# LSP events

| **Workflow Title**                               | **Neovim Event**                                                 | **LSP Actions**                                                                                                                    | **Description / Logic**                                                                                                                                                                                                                                                                                                                                                                                                                            |
|--------------------------------------------------|------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Attach LSP Client to Buffer**                  | `BufReadPost`, `BufNewFile`                                      | 1. Checks if a matching LSP server is configured for the filetype<br>2. Attaches the LSP client if not already attached<br>3. Sends `textDocument/didOpen` to server       | **Logic**: When a buffer is opened (file read) or created (new file), Neovim checks if an LSP server should handle this filetype. If yes, the built-in client attaches. Attaching includes sending the entire buffer’s content to the server as a `didOpen` notification.<br><br>**Diagnostics**: Initially, the server may respond with diagnostics for that file. Neovim then updates the diagnostic display (signs, virtual text, etc.).                              |
| **Detach LSP Client from Buffer**                | `BufUnload`, `BufDelete`                                         | Sends `textDocument/didClose` to the server                                                                                         | **Logic**: When the buffer is unloaded or deleted, the LSP client notifies the server that the text document is closed. This frees resources on the server side.<br><br>**Diagnostics**: Once detached, no further diagnostics are published for that buffer, and local LSP interactions end unless you re-attach.                                                                                                                                         |
| **Send didChange upon Buffer Modifications**     | `TextChanged`, `TextChangedI`, `InsertLeave`                     | Sends `textDocument/didChange` (incremental changes) to the server (with a short debounce)                                         | **Logic**: Whenever you change text (normal or insert mode), the LSP client accumulates edits and sends them to the server in an incremental `didChange` request. By default, there’s a short debounce so you don’t send a request on every keystroke.<br><br>**Diagnostics**: The server uses these updates to recompute diagnostics. When the server publishes new diagnostics, Neovim updates signs, virtual text, etc., in real time.                                 |
| **Saving the Buffer (Pre/Post Save Logic)**      | `BufWritePre`, `BufWritePost`                                    | - (Optional) `textDocument/willSave`<br>- (Optional) `textDocument/didSave`<br>- (Optional) `vim.lsp.buf.format()`                  | **Logic**:<br>• On `BufWritePre`, you may configure auto-formatting via `vim.lsp.buf.format()`. Some servers support `willSave`, which can be sent before writing if enabled.<br>• On `BufWritePost`, the client can send `didSave` if `send_notification.didSave = true` in the server config. Some servers re-check or trigger additional tasks on `didSave`.<br><br>**Diagnostics**: The server often re-publishes diagnostics right after save if anything changed. |
| **Diagnostics & Floating Windows**               | `CursorHold`, `CursorHoldI`, sometimes `InsertLeave`             | Typically no LSP request here; triggers local `vim.diagnostic.open_float()` or other local diagnostic display methods              | **Logic**: When the cursor is held still (`CursorHold`) or you exit insert mode (`InsertLeave`), you can auto-show a floating diagnostic window (`vim.diagnostic.open_float()`).<br><br>**Diagnostics**: The built-in diagnostic system updates automatically as soon as the server publishes new diagnostics. These events merely trigger the floating window display if you configure it. No additional server request is made.                                  |
| **CodeLens or Inlay Hint Refresh**               | `CursorHold`, `BufEnter`, sometimes `InsertLeave`                | Sends `textDocument/codeLens` requests (or `textDocument/inlayHint`) to the server                                                 | **Logic**: A user config might call `vim.lsp.codelens.refresh()` on these events, prompting Neovim to request updated code lens or inlay hints.<br><br>**Diagnostics**: Code lens and inlay hints are separate from normal diagnostics, but similarly, the server can also republish diagnostic info at any time.                                                                                                                                              |
| **Manual or Automatic Completion**               | Typically plugin-driven (e.g., `InsertCharPre`, `TextChangedI`)   | `textDocument/completion` (on-demand)                                                                                              | **Logic**: Autocompletion usually comes from plugins (like `nvim-cmp`). These plugins request completion items from the server as you type or when you trigger completion manually.<br><br>**Diagnostics**: This doesn’t directly affect diagnostics. However, if server logic updates anything during completion, it may publish new diagnostics.                                                                                                                  |
| **Manual LSP Detach**                            | `LspDetach` (Neovim ≥ 0.8)                                       | Client de-initialization and resource cleanup                                                                                     | **Logic**: If you explicitly detach the LSP client (via code or user action), this event fires. It’s similar to `BufUnload` except it’s a direct detach from the LSP side. You might clean up buffer-local settings or mappings here.<br><br>**Diagnostics**: After detaching, no further diagnostics from that server are updated for this buffer.                                                                                                          |

